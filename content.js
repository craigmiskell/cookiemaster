/*
  Copyright 2017 Craig Miskell

  This file is part of CookieMaster, a Firefox Web Extension
  CookieMaster is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  CookieMaster is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
A content script injected into *every* page, that hooks document.cookie
so that we can detect a cookie being set by javascript more accurately
than just receiving the cookies.onChanged notification (with no tab/frame info)

It's a bit funky, in that we have to use window.eval to run the hook code in
the context of the *page* (the content-script context is sandboxed from that) so
as to be able to hook the cookies property in the first place

Now you might think we should call into the background page to do the validation
but that is async and setting the cookie only happens a bit later when that
call returns.  So any code that sets and then *immediately* checks for that
cookie will fail (this happens for real, e.g. hushmail.com).  So we have to
use window.dispatchEvent (synchronous), do the validation on the content-script
context, and only the notify the background script of what the decision was
for recording.  It's a smidgen more complicated than desirable, but seems to
work.  Yay for async.... :(
*/
var config;
function loadConfig() {
  getConfig().then(function(result) {
    config = result;
    //console.log("Loaded config in content script");
  });
}

window.addEventListener("scriptedCookieSet", async function(e) {
  var response = allowScriptedCookieSet(cookieparse(e.detail), window.location)
  if(response == undefined) {
    return; // Was a delete; nothing else to do
  }
  if(response.allowed) {
    // This relies on https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Xray_vision
    // where this event handler is in the *content-script* context and thus
    // gets a 'clean' view of the document, and thus doesn't see the overridden
    // cookie property setter that we create in the *window* context (via `eval`)
    // Side note: this x-ray vision thing is both good (security), and annoying
    // (requires shenanigans), *except* in this case when it's really helpful
    // because otherwise we'd have to send events back to the window context,
    // which is actually painful, and has security-risk implications (passing
    // objects, trusting the messages, etc)
    document.cookie = e.detail;
  }
  // Note that some of the information we need (tabId + frameId) is generated by
  // browser.runtime (we can"t easily get it in this context), and is critical
  await browser.runtime.sendMessage({
     "name": "scriptedCookieEvent",
     "domain": response.domain,
     "configDomain": response.configDomain,
     "allowed": response.allowed
  });
});

browser.runtime.onMessage.addListener(message => {
  switch (message.name) {
    case "configChanged":
      loadConfig();
      break;
    }
});

loadConfig();

var cookieDateParser = new CookieDateParser();
// Inspects the expires and max-age attribute values of the cookie
// and returns true if either of those are set in a way that means the cookie
// should be deleted (not set)
function cookieIsBeingDeleted(cookie, date = new Date()) {
  var expires;
  if(cookie.hasOwnProperty('expires')) {
    expires = cookieDateParser.parseDate(cookie['expires'])
    //NB: may still be undefined if the expires av is malformed, this is fine
  }
  //Will be false if 'expires' is undefined.
  if(expires <= date) {
    return true
  } else if (cookie.hasOwnProperty('max-age') && (cookie['max-age'] <= 0)) {
    return true;
  }
  return false;
}

function allowScriptedCookieSet(cookie, url) {
  if (cookieIsBeingDeleted(cookie)) {
    return undefined;
  }
  var domain = new URL(url).hostname;
  var configDomain = domainIsAllowed(config, domain);
  //Record this activity against the configuration domain which allowed the
  // cookie, otherwise use the domain of the cookie itself when blocking.
  var recordDomain = configDomain || domain;
  return {
    "allowed": (configDomain != undefined),
    "domain": domain,
    "configDomain": configDomain
  }
}


// Many thanks to @gregers on https://stackoverflow.com/questions/32410331/proxying-of-document-cookie
// for inspiration.
window.eval(`
  var cookiePropertyDescriptor = Object.getOwnPropertyDescriptor(Document.prototype, "cookie");
  Object.defineProperty(Document.prototype, "cookie", {
    get: cookiePropertyDescriptor.get,
    set: function(value) {
      var event = new CustomEvent("scriptedCookieSet",
        {
          detail: value
        }
      );
      // It is absolutely critical that this call to dispatchEvent is, as the
      // documentation claims, synchronous (not async).  It *must* execute
      // the event handling code, in the content-script context, and set the
      // cookie (if allowed) before this 'set' implementation finishes and
      // returns, otherwise it does not accurately emulate the interface.  Code
      // that then goes to immediately retrieve the cookie (e.g. testing
      // if cookies are settable) will fail if this requirement is not met.
      window.dispatchEvent(event);
    }
  });
`);
